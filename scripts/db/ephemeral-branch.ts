#!/usr/bin/env tsx
/**
 * Ephemeral Neon Branch Management for Testing
 *
 * Creates a fresh, isolated Neon branch for test runs. This ensures:
 * - Tests run against a known, seeded state
 * - No interference from development data changes
 * - Parallel test runs don't conflict
 *
 * Usage:
 *   tsx scripts/db/ephemeral-branch.ts create   # Create branch and seed
 *   tsx scripts/db/ephemeral-branch.ts delete   # Delete branch and cleanup
 *
 * Prerequisites:
 *   - Pulumi staging stack deployed (to get Neon project ID)
 *   - Authenticated with Neon: pnpm exec neonctl auth
 *
 * Output:
 *   Creates .env.test with DATABASE_URL pointing to ephemeral branch
 */

import { execSync, spawnSync } from "node:child_process";
import { writeFileSync, readFileSync, existsSync, unlinkSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ENV_TEST_FILE = resolve(__dirname, "../../.env.test");

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function neonctl(args: string): string {
  const result = spawnSync("pnpm", ["exec", "neonctl", ...args.split(" ")], {
    encoding: "utf-8",
    cwd: resolve(__dirname, "../.."),
  });
  if (result.status !== 0) {
    throw new Error(`neonctl failed: ${result.stderr || result.stdout}`);
  }
  return result.stdout.trim();
}

function getProjectId(): string {
  // Get from Pulumi staging stack (dynamically created by infra)
  try {
    const infraPath = resolve(__dirname, "../../infra");
    const projectId = execSync(
      `pulumi -C ${infraPath} stack output neonProjectId --stack staging`,
      { encoding: "utf-8", cwd: __dirname }
    ).trim();
    return projectId;
  } catch {
    console.error("‚ùå Failed to get Neon project ID from Pulumi");
    console.error("   Ensure staging stack is deployed: pnpm infra:up:staging");
    process.exit(1);
  }
}

function getBranchName(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 6);
  return `test-${timestamp}-${random}`;
}

function readBranchFromEnv(): string | null {
  if (!existsSync(ENV_TEST_FILE)) {
    return null;
  }
  const content = readFileSync(ENV_TEST_FILE, "utf-8");
  const match = content.match(/^NEON_BRANCH_NAME=(.+)$/m);
  return match ? match[1] : null;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Create Branch
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function createBranch() {
  console.log("üåø Creating ephemeral Neon branch for testing...\n");

  const projectId = getProjectId();
  const branchName = getBranchName();

  console.log(`   Project ID: ${projectId}`);
  console.log(`   Branch Name: ${branchName}`);

  // Create the branch from main
  console.log("\nüì¶ Creating branch from main...");
  try {
    neonctl(`branches create --name ${branchName} --project-id ${projectId}`);
    console.log(`   ‚úÖ Branch '${branchName}' created`);
  } catch (error) {
    console.error("‚ùå Failed to create branch:", error);
    process.exit(1);
  }

  // Get connection string (use neondb_owner role for full access)
  console.log("\nüîó Getting connection string...");
  const connectionString = neonctl(
    `connection-string ${branchName} --project-id ${projectId} --role-name neondb_owner`
  );

  // Write .env.test files for both packages
  const envContent = `# Auto-generated by ephemeral-branch.ts - DO NOT COMMIT
# This file is used for test isolation
DATABASE_URL="${connectionString}"
NEON_BRANCH_NAME=${branchName}
NEON_PROJECT_ID=${projectId}
`;

  writeFileSync(ENV_TEST_FILE, envContent);
  console.log(`   ‚úÖ Wrote ${ENV_TEST_FILE}`);

  // Run migrations
  console.log("\nüîÑ Running migrations...");
  try {
    execSync("pnpm db:migrate:all", {
      cwd: resolve(__dirname, "../.."),
      stdio: "inherit",
      env: { ...process.env, DATABASE_URL: connectionString },
    });
    console.log("   ‚úÖ Migrations complete");
  } catch (error) {
    console.error("‚ùå Migrations failed:", error);
    // Cleanup on failure
    await deleteBranch(branchName, projectId);
    process.exit(1);
  }

  // Run seed
  console.log("\nüå± Seeding database...");
  try {
    execSync("pnpm db:seed", {
      cwd: resolve(__dirname, "../.."),
      stdio: "inherit",
      env: { ...process.env, DATABASE_URL: connectionString },
    });
    console.log("   ‚úÖ Seed complete");
  } catch (error) {
    console.error("‚ùå Seeding failed:", error);
    await deleteBranch(branchName, projectId);
    process.exit(1);
  }

  console.log("\n" + "‚îÄ".repeat(60));
  console.log("‚úÖ Ephemeral test branch is ready!");
  console.log(`   Branch: ${branchName}`);
  console.log("‚îÄ".repeat(60));
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Delete Branch
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function deleteBranch(branchName?: string, projectId?: string) {
  console.log("üóëÔ∏è  Cleaning up ephemeral Neon branch...\n");

  // Read from env file if not provided
  if (!branchName) {
    branchName = readBranchFromEnv() ?? undefined;
    if (!branchName) {
      console.log("   ‚ö†Ô∏è  No ephemeral branch found to delete");
      return;
    }
  }

  if (!projectId) {
    // Try to read from .env.test first (saved during create)
    if (existsSync(ENV_TEST_FILE)) {
      const content = readFileSync(ENV_TEST_FILE, "utf-8");
      const match = content.match(/^NEON_PROJECT_ID=(.+)$/m);
      projectId = match ? match[1] : undefined;
    }
    // Fall back to Pulumi
    if (!projectId) {
      projectId = getProjectId();
    }
  }

  console.log(`   Project ID: ${projectId}`);
  console.log(`   Branch Name: ${branchName}`);

  // Delete the branch
  console.log("\nüóëÔ∏è  Deleting branch...");
  try {
    neonctl(`branches delete ${branchName} --project-id ${projectId}`);
    console.log(`   ‚úÖ Branch '${branchName}' deleted`);
  } catch (error) {
    // Branch might already be deleted
    console.log(`   ‚ö†Ô∏è  Branch deletion returned: ${error}`);
  }

  // Clean up .env.test file
  if (existsSync(ENV_TEST_FILE)) {
    unlinkSync(ENV_TEST_FILE);
    console.log(`   ‚úÖ Removed ${ENV_TEST_FILE}`);
  }

  console.log("\n‚úÖ Cleanup complete!");
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CLI
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const command = process.argv[2];

switch (command) {
  case "create":
    createBranch().catch((error) => {
      console.error("‚ùå Create failed:", error);
      process.exit(1);
    });
    break;
  case "delete":
    deleteBranch().catch((error) => {
      console.error("‚ùå Delete failed:", error);
      process.exit(1);
    });
    break;
  default:
    console.log("Usage: tsx scripts/db/ephemeral-branch.ts <create|delete>");
    console.log("");
    console.log("Commands:");
    console.log("  create   Create a fresh ephemeral branch and seed it");
    console.log("  delete   Delete the ephemeral branch and cleanup");
    process.exit(1);
}
